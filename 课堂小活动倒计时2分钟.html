<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2分钟课堂倒计时</title>
    <!-- 引入Tailwind CSS框架 -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- 引入Google字体'Orbitron'，具有科技感 -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* 使用Orbitron字体 */
        body {
            font-family: 'Orbitron', sans-serif;
        }

        /* 为计时器数字添加脉冲发光动画 */
        @keyframes pulseGlow {
            0%, 100% {
                text-shadow: 0 0 8px #0ff, 0 0 16px #0ff, 0 0 24px #0ff;
            }
            50% {
                text-shadow: 0 0 16px #0ff, 0 0 32px #0ff, 0 0 48px #0ff, 0 0 64px #00aaff;
            }
        }

        .timer-display {
            animation: pulseGlow 4s ease-in-out infinite;
        }

        /* 时间到时的闪烁警告动画 */
        @keyframes timeUpFlash {
            0%, 49%, 100% {
                color: #ff3b3b;
                text-shadow: 0 0 10px #ff3b3b, 0 0 20px #ff3b3b;
            }
            50%, 99% {
                color: #fff;
                text-shadow: none;
            }
        }

        .time-up-animation {
            animation: timeUpFlash 1.5s infinite;
        }

        /* 自定义按钮样式，添加过渡效果 */
        .control-btn {
            transition: all 0.3s ease;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.5), inset 0 0 5px rgba(0, 255, 255, 0.3);
        }
        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.8), inset 0 0 10px rgba(0, 255, 255, 0.5);
        }
        .control-btn:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body class="bg-gray-900 text-white font-sans overflow-hidden">
    <!-- 动态粒子背景的Canvas画布 -->
    <canvas id="particle-canvas" class="absolute top-0 left-0 w-full h-full z-0"></canvas>
    
    <!-- 主内容容器，使用flex布局使其居中 -->
    <div class="relative min-h-screen flex flex-col items-center justify-center z-10 p-4">
        <header class="text-center mb-8 md:mb-12">
            <h1 class="text-3xl md:text-5xl font-bold tracking-widest" style="text-shadow: 0 0 10px #0ff;">课堂活动倒计时</h1>
            <p class="text-cyan-300 mt-2 text-sm md:text-base">CLASS ACTIVITY TIMER</p>
        </header>

        <!-- 计时器显示区域 -->
        <div id="timer-container" class="timer-display text-8xl sm:text-9xl md:text-[12rem] font-bold flex items-center justify-center select-none">
            <span id="minutes">02</span>
            <span>:</span>
            <span id="seconds">00</span>
        </div>

        <!-- 控制按钮区域 -->
        <div class="flex space-x-4 md:space-x-8 mt-10 md:mt-16">
            <button id="start-pause-btn" class="control-btn bg-cyan-500/20 border border-cyan-400 text-cyan-300 rounded-full w-24 h-24 md:w-32 md:h-32 text-2xl md:text-3xl font-bold flex items-center justify-center">
                开始
            </button>
            <button id="reset-btn" class="control-btn bg-pink-500/20 border border-pink-400 text-pink-300 rounded-full w-24 h-24 md:w-32 md:h-32 text-2xl md:text-3xl font-bold flex items-center justify-center">
                重置
            </button>
        </div>
    </div>

    <script>
        // --- 倒计时器逻辑 ---
        const minutesEl = document.getElementById('minutes');
        const secondsEl = document.getElementById('seconds');
        const startPauseBtn = document.getElementById('start-pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        const timerContainer = document.getElementById('timer-container');

        const DURATION = 120; // 总时长为120秒
        let timeRemaining = DURATION;
        let timerId = null;
        let isRunning = false;

        // 更新显示
        function updateDisplay() {
            const minutes = Math.floor(timeRemaining / 60);
            const seconds = timeRemaining % 60;
            minutesEl.textContent = String(minutes).padStart(2, '0');
            secondsEl.textContent = String(seconds).padStart(2, '0');
        }

        // 开始或暂停计时器
        function toggleTimer() {
            if (isRunning) {
                // 暂停
                clearInterval(timerId);
                startPauseBtn.textContent = '继续';
                isRunning = false;
            } else {
                // 开始或继续
                timerContainer.classList.remove('time-up-animation');
                startPauseBtn.textContent = '暂停';
                isRunning = true;
                timerId = setInterval(() => {
                    timeRemaining--;
                    updateDisplay();
                    if (timeRemaining <= 0) {
                        clearInterval(timerId);
                        isRunning = false;
                        timerContainer.classList.add('time-up-animation');
                        minutesEl.textContent = '时间';
                        secondsEl.textContent = '到!';
                        startPauseBtn.textContent = '开始';
                        timeRemaining = DURATION;
                    }
                }, 1000);
            }
        }

        // 重置计时器
        function resetTimer() {
            clearInterval(timerId);
            timerContainer.classList.remove('time-up-animation');
            timeRemaining = DURATION;
            isRunning = false;
            startPauseBtn.textContent = '开始';
            updateDisplay();
        }

        // 绑定事件
        startPauseBtn.addEventListener('click', toggleTimer);
        resetBtn.addEventListener('click', resetTimer);

        // 初始显示
        updateDisplay();


        // --- 动态粒子背景逻辑 ---
        const canvas = document.getElementById('particle-canvas');
        const ctx = canvas.getContext('2d');

        let particlesArray;

        // 设置画布尺寸
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // 监听窗口大小变化
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initParticles();
        });

        // 定义粒子类
        class Particle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x;
                this.y = y;
                this.directionX = directionX;
                this.directionY = directionY;
                this.size = size;
                this.color = color;
            }
            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
            }
            update() {
                if (this.x > canvas.width || this.x < 0) {
                    this.directionX = -this.directionX;
                }
                if (this.y > canvas.height || this.y < 0) {
                    this.directionY = -this.directionY;
                }
                this.x += this.directionX;
                this.y += this.directionY;
                this.draw();
            }
        }

        // 创建粒子
        function initParticles() {
            particlesArray = [];
            let numberOfParticles = (canvas.height * canvas.width) / 9000;
            for (let i = 0; i < numberOfParticles; i++) {
                let size = (Math.random() * 2) + 1;
                let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                let directionX = (Math.random() * .4) - .2;
                let directionY = (Math.random() * .4) - .2;
                let color = 'rgba(0, 255, 255, 0.5)';
                particlesArray.push(new Particle(x, y, directionX, directionY, size, color));
            }
        }
        
        // 连接粒子
        function connectParticles() {
            let opacityValue = 1;
            for (let a = 0; a < particlesArray.length; a++) {
                for (let b = a; b < particlesArray.length; b++) {
                    let distance = ((particlesArray[a].x - particlesArray[b].x) * (particlesArray[a].x - particlesArray[b].x)) +
                        ((particlesArray[a].y - particlesArray[b].y) * (particlesArray[a].y - particlesArray[b].y));
                    if (distance < (canvas.width / 7) * (canvas.height / 7)) {
                        opacityValue = 1 - (distance / 20000);
                        ctx.strokeStyle = `rgba(0, 255, 255, ${opacityValue})`;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        ctx.moveTo(particlesArray[a].x, particlesArray[a].y);
                        ctx.lineTo(particlesArray[b].x, particlesArray[b].y);
                        ctx.stroke();
                    }
                }
            }
        }

        // 动画循环
        function animateParticles() {
            requestAnimationFrame(animateParticles);
            ctx.clearRect(0, 0, innerWidth, innerHeight);
            for (let i = 0; i < particlesArray.length; i++) {
                particlesArray[i].update();
            }
            connectParticles();
        }
        
        initParticles();
        animateParticles();
    </script>
</body>
</html>
